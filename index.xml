<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端笔记</title>
    <link>https://convee.github.io/</link>
    <description>Recent content on 后端笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://convee.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mysql 知识点</title>
      <link>https://convee.github.io/post/mysql/summary/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/mysql/summary/</guid>
      <description>SQL 执行流程 Server 层  连接器：TCP 握手后服务器来验证登录用户身份，A 用户创建连接后，管理员对 A 用户权限修改了也不会影响到已经创建的链接权限，必须重新登录 查询缓存：查询后的结果存储位置 分析器：根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法 优化器：多种执行策略可实现目标，系统自动选择最优进行执行 执行器：判断是否有权限将最终任务提交到存储引擎  存储引擎层  InnoDB MyISAM Memory  SQL 执行顺序 BinLog、RedoLog、UndoLog BinLog 记录所有数据库表结构变更以及数据修改的二进制日志，主从数据库同步用到的都是 BinLog 文件，BinLog 日志有三种模式：
STATMENT 模式 ROW 模式 MIXED 模式 主从同步流程  主节点必须启用二进制日志，记录任何修改了数据的事件 从节点开启一个线程（I/O Thread）把自己扮演成 mysql 客户端，通过 mysql 协议，请求主节点的二进制文件中的事件 主节点启动一个线程（dump Thread），检查自己二进制中的事件，跟对方请求的位置对比，如果不带请求位置参数，则主节点会从第一个日志文件中的第一个事件一个一个的发送从节点。 从节点接收到主节点发过来的数据把它放置在中继日志（Relay log ）中。并记录该次请求到主节点的具体的哪一个二进制文件的哪一个位置（主节点二进制文件会有多个）。 从节点启动另一个线程（sql Thread），把 Relay log 中的事件读取出来，并在本地再执行一次。  </description>
    </item>
    
    <item>
      <title>算法-链表</title>
      <link>https://convee.github.io/post/algorithm/linked-list/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/linked-list/</guid>
      <description>链表 概念 链表是一种线性数据结构，其中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。 特点 单链表 双链表 </description>
    </item>
    
    <item>
      <title>Go 问题集</title>
      <link>https://convee.github.io/post/go/faq/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/go/faq/</guid>
      <description>Go 内置函数  close：主要用来关闭channel len：用来求长度，比如string,array,slice,map,channel new：用来分配内存，主要用来分配值类型，比如int,struct。返回的是指针 make：用来分配内存，主要用来分配引用类型，比如chan,slice,map append：用来追加元素到数组、切片中，非线程安全 panic和recover：用来做错误处理  高效拼接字符串 Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 strings.Builder，最小化内存拷贝次数。
var str strings.Builder for i := 0; i &amp;lt; 1000; i++ { str.WriteString(&amp;#34;a&amp;#34;) } fmt.Println(str.String()) 字节序 大小端问题主要涉及的是非单字节非字符串外的其余数据的表示和传递，如short型、int型等。大端和小端有其各自的优势。我们知道计算机正常的内存增长方式是从低到高(当然栈不是)，取数据方式是从基址根据偏移找到他们的位置，从他们的存储方式可以看出，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。而小端存储 第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。
rune 与 byte 类型  在unicode中，一个中文占两个字节，utf-8中一个中文占三个字节，golang默认的编码是utf-8编码，因此默认一个中文占三个字节 rune类型的底层类型是int32类型，适合表达unicode字符 byte类型的底层类型是int8类型，适合表达ascii编码的字符 rune能处理一切的字符，而byte仅仅局限在ascii  fmt.Println(len(&amp;#34;Go语言&amp;#34;)) // 8 fmt.Println(len([]rune(&amp;#34;Go语言&amp;#34;))) // 4 Go 单引号、双引号与反引号  双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行) 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式 单引号则用于表示Golang的一个特殊类型：rune，类似其他语言的byte但又不完全一样，是指：码点字面量（Unicode code point），不做任何转义的原始内容。  </description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://convee.github.io/post/go/slice/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/go/slice/</guid>
      <description>Slice 实现原理  Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。接下来按照实际使用场景分别介绍其实现机制  Slice 数据结构 type slice struct { ​ array unsafe.Pointer ​ len int ​ cap int } 使用 make 创建 Slice slice := make([]int, 5, 10) 使用数组创建 Slice  使用数组来创建Slice时，Slice将与原数组共用一部分内存 切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5 数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方  slice := array[5:7] Slice 扩容  使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍 使用append()向Slice添加一个元素的实现步骤如下：  假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice 将新元素追加进新Slice，Slice.len++，返回新的Slice    Slice Copy  使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。 例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，copy过程中不会发生扩容。  特殊切片  跟据数组或切片生成新的切片一般使用slice := array[start:end]方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。 比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：  sliceA := make([]int, 5, 10) sliceB := sliceA[0:5]  根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：  ​sliceA := make([]int, 5, 10) //length = 5; capacity = 10 ​sliceB := sliceA[0:5] //length = 5; capacity = 10 sliceC := sliceA[0:5:5] //length = 5; capacity = 5 编程Tips  创建切片时可跟据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能； 切片拷贝时需要判断实际拷贝的元素个数 谨慎使用多个切片操作同一个数组，以防读写冲突  Slice总结  每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片  </description>
    </item>
    
    <item>
      <title>Go 管道</title>
      <link>https://convee.github.io/post/go/chan/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/go/chan/</guid>
      <description>chan 数据结构： type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写 } 环形队列  chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的 make(chan int, 6) dataqsiz指示了队列长度为6，即可缓存6个元素； buf指向队列的内存，队列中还剩余两个元素； qcount表示队列中还有两个元素； sendx指示后续写入的数据存储的位置，取值[0, 6)； recvx指示从该位置读取数据, 取值[0, 6)；  等待队列  从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。 被阻塞的goroutine将会挂在channel的等待队列中：  因读阻塞的goroutine会被向channel写入数据的goroutine唤醒； 因写阻塞的goroutine会被从channel读数据的goroutine唤醒；   注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。  类型信息  一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。 elemtype代表类型，用于数据传递过程中的赋值； elemsize代表类型大小，用于在buf中定位元素位置。  锁  一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。  创建 chan  创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定  func makechan(t *chantype, size int) *hchan { var c *hchan c = new(hchan) c.</description>
    </item>
    
    <item>
      <title>Mysql 创建用户与授权</title>
      <link>https://convee.github.io/post/mysql/grant/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/mysql/grant/</guid>
      <description>创建用户 命令: CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;; 说明：  username：用户名 host：用户可以登录的主机 password：用户登录密码，密码可以为空  例子： CREATE USER &#39;convee&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; CREATE USER &#39;convee&#39;@&#39;192.168.0.1_&#39; IDENDIFIED BY &#39;123456&#39;; CREATE USER &#39;convee&#39;@&#39;192.168.%.%&#39; IDENTIFIED BY &#39;123456&#39;; CREATE USER &#39;convee&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;; CREATE USER &#39;convee&#39;@&#39;%&#39;; 授权: 命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; 说明:  privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.*  例子: GRANT SELECT, INSERT ON test.user TO &#39;convee&#39;@&#39;%&#39;; GRANT ALL ON *.* TO &#39;convee&#39;@&#39;%&#39;; 注意:  用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:  GRANT privileges ON databasename.</description>
    </item>
    
    <item>
      <title>Mysql 备份与恢复</title>
      <link>https://convee.github.io/post/mysql/backup/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/mysql/backup/</guid>
      <description>恢复到指定数据库 mysql -hhostname -uusername -ppassword databasename &amp;lt; backup.sql 还原压缩的MySQL数据备份文件 gunzip &amp;lt; backup.sql.gz | mysql -uusername -ppassword databasename 直接将备份导入到新的数据库 mysqldump -uusername -ppassword databasename | mysql -host=192.168.0.1 -C databasename 使用source导入sql文件 mysql &amp;gt; use test mysql &amp;gt; source /data/test_backup.sql </description>
    </item>
    
    <item>
      <title>PHP Redis 扩展安装</title>
      <link>https://convee.github.io/post/php/redis-ext/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/php/redis-ext/</guid>
      <description>下载源码 wget https://github.com/phpredis/phpredis/archive/5.3.2.tar.gz 解压 tar -zxvf 5.4.3.tag.gz 进入源码目录 cd phpredis-5.3.2 侦测环境  并生成相应的配置文件（包括 configure）phpize 为当前环境下的命令，与 php 是同一级别的  /usr/local/php7/bin/phpize 检查配置与依赖 ./configure [--enable-redis-igbinary] [--enable-redis-msgpack] [--enable-redis-lzf [--with-liblzf[=DIR]]] [--enable-redis-zstd] 编译  会在 modules 目录下生成 redis.so 文件， 复制到 extension_dir 目录下，扩展会成功  make 安装 make install phpredis 文档 https://github.com/phpredis/phpredis/blob/develop/INSTALL.markdown</description>
    </item>
    
    <item>
      <title>算法-二叉树</title>
      <link>https://convee.github.io/post/algorithm/binary-tree/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/binary-tree/</guid>
      <description>二叉树遍历  前序遍历：先访问根结点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根结点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根结点  注意点：  以根访问顺序决定是什么遍历 左子树都是优先右子树  前序递归 func preorderTraversal(root *TreeNode) { if root==nil{ return } // 先访问根再访问左右  fmt.Println(root.Val) preorderTraversal(root.Left) preorderTraversal(root.Right) } 前序非递归 // V3：通过非递归遍历 func preorderTraversal(root *TreeNode) []int { // 非递归  if root == nil{ return nil } result:=make([]int,0) stack:=make([]*TreeNode,0) for root!=nil || len(stack)!=0{ for root !=nil{ // 前序遍历，所以先保存结果  result=append(result,root.Val) stack=append(stack,root) root=root.Left } // pop  node:=stack[len(stack)-1] stack=stack[:len(stack)-1] root=node.Right } return result } 中序非递归 // 思路：通过stack 保存已经访问的元素，用于原路返回 func inorderTraversal(root *TreeNode) []int { result := make([]int, 0) if root == nil { return result } stack := make([]*TreeNode, 0) for len(stack) &amp;gt; 0 || root !</description>
    </item>
    
    <item>
      <title>算法-二进制</title>
      <link>https://convee.github.io/post/algorithm/binary/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/binary/</guid>
      <description>常见的二进制操作 位运算    符号 描述 运算规则     &amp;amp; 与 两个位都为1时，结果才为1   ｜ 或 两个位都为0时，结果才为0   ^ 异或 两个位相同为0，相异为1   ~ 取反 0变1，1变0   &amp;laquo; 左移 高位丢弃，低位补0      |右移|正数左补0，负数左补1，右边丢弃
  基本操作  a=a^0=0^a 0=a^a a=a^b^b  交换两个数  a=a^b b=a^b a=a^b  移除最后一个 1  a=n&amp;amp;(n-1)  获取最后一个 1  diff=(n&amp;amp;(n-1))^n  </description>
    </item>
    
    <item>
      <title>算法思维</title>
      <link>https://convee.github.io/post/algorithm/algorithm/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/algorithm/</guid>
      <description>学习算法和刷题框架思维 数据结构存储方式 数组（顺序存储）  紧凑连续存储，可以随机访问 通过索引快速找到对应元素 相对节约存储空间 正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N) 如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)  链表（链式存储）  元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题 如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1) 正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问 由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间  数据结构比较 链表 队列和栈  数组：处理扩容问题 链表：需要更多的内存空间存储节点指针  图  邻接表（链表）：省空间，操作效率不如邻接矩阵 邻接矩阵（二维数组）：判断连通性迅速，如果图稀疏很耗空间  散列表  通过散列函数把键映射到一个大数组中 拉链法需要链表特性，操作简单，需要额外的空间存储指针 线性探查法需要数组特性，以便连续寻址，不需要指针的存储空间，操作复杂  树  数组实现就是「堆」，「堆」是一个完全二叉树，用数组存储不需要节点指针，操作简单 链表实现是常见的树，因为不一定是完全二叉树，所以不适合用数组存储  字符串 数组和矩阵 图 位运算 数据结构的基本操作 遍历访问（增删改查） 形式  线性（迭代） 非线性（递归）  框架  数组遍历  func traverse(arr []int) { for (int i := 0; i &amp;lt; len(arr); i++) { // 迭代访问 arr[i]  } }  链表遍历  // 单链表 type ListNode struct{ Val int Next *ListNode } // 遍历 func traverse1(head *ListNode) { for head !</description>
    </item>
    
    <item>
      <title>编译安装PHP</title>
      <link>https://convee.github.io/post/php/install/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/php/install/</guid>
      <description>安装依赖包 yum install -y gcc gcc-c++ make zlib zlib-devel pcre pcre-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp gmp-devel expat-devel libxml2 libxml2-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel libcurl libcurl-devel curl curl-devel libmcrypt libmcrypt-devel libxslt libxslt-devel xmlrpc-c xmlrpc-c-devel libicu-devel libmemcached-devel libzip readline readline-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers 下载 PHP wget https://www.php.net/distributions/php-7.3.20.tar.gz 解压 tar -xzvf php-7.3.20.tar.gz cd php-7.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://convee.github.io/about/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:54 +0800</pubDate>
      
      <guid>https://convee.github.io/about/</guid>
      <description>大家好</description>
    </item>
    
    <item>
      <title></title>
      <link>https://convee.github.io/post/algorithm/queue-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/queue-stack/</guid>
      <description> </description>
    </item>
    
    <item>
      <title></title>
      <link>https://convee.github.io/post/linux/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/linux/io/</guid>
      <description>IO 多路复用 </description>
    </item>
    
  </channel>
</rss>
