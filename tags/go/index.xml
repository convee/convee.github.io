<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Backend-Notes</title>
    <link>https://convee.github.io/tags/go/</link>
    <description>Recent content in go on Backend-Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://convee.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 信道</title>
      <link>https://convee.github.io/post/chan/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/chan/</guid>
      <description>chan 数据结构： type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写 } 环形队列  chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的 make(chan int, 6) dataqsiz指示了队列长度为6，即可缓存6个元素； buf指向队列的内存，队列中还剩余两个元素； qcount表示队列中还有两个元素； sendx指示后续写入的数据存储的位置，取值[0, 6)； recvx指示从该位置读取数据, 取值[0, 6)；  等待队列  从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。 被阻塞的goroutine将会挂在channel的等待队列中： ** 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒； ** 因写阻塞的goroutine会被从channel读数据的goroutine唤醒； 注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。  类型信息  一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。 elemtype代表类型，用于数据传递过程中的赋值； elemsize代表类型大小，用于在buf中定位元素位置。  锁  一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。  创建 chan  创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定  func makechan(t *chantype, size int) *hchan { var c *hchan c = new(hchan) c.</description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://convee.github.io/post/slice/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/slice/</guid>
      <description>Slice 实现原理  Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。接下来按照实际使用场景分别介绍其实现机制  Slice 数据结构 type slice struct { ​ array unsafe.Pointer ​ len int ​ cap int } 使用 make 创建 Slice slice := make([]int, 5, 10) 使用数组创建 Slice  使用数组来创建Slice时，Slice将与原数组共用一部分内存 切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5 数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方  slice := array[5:7] Slice 扩容  使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍 使用append()向Slice添加一个元素的实现步骤如下： ** 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice ** 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice ** 将新元素追加进新Slice，Slice.len++，返回新的Slice  Slice Copy  使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。 例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，copy过程中不会发生扩容。  特殊切片  跟据数组或切片生成新的切片一般使用slice := array[start:end]方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。 比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：  sliceA := make([]int, 5, 10) sliceB := sliceA[0:5]  根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：  ​ sliceA := make([]int, 5, 10) //length = 5; capacity = 10 ​ sliceB := sliceA[0:5] //length = 5; capacity = 10 ​ sliceC := sliceA[0:5:5] //length = 5; capacity = 5 编程Tips  创建切片时可跟据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能； 切片拷贝时需要判断实际拷贝的元素个数 谨慎使用多个切片操作同一个数组，以防读写冲突  Slice总结  每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片  </description>
    </item>
    
  </channel>
</rss>
