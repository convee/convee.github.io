<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Backend-Notes</title>
    <link>https://convee.github.io/post/</link>
    <description>Recent content in Posts on Backend-Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://convee.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 信道</title>
      <link>https://convee.github.io/post/chan/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/chan/</guid>
      <description>chan 数据结构： type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写 } 环形队列  chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的 make(chan int, 6) dataqsiz指示了队列长度为6，即可缓存6个元素； buf指向队列的内存，队列中还剩余两个元素； qcount表示队列中还有两个元素； sendx指示后续写入的数据存储的位置，取值[0, 6)； recvx指示从该位置读取数据, 取值[0, 6)；  等待队列  从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。 被阻塞的goroutine将会挂在channel的等待队列中： ** 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒； ** 因写阻塞的goroutine会被从channel读数据的goroutine唤醒； 注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。  类型信息  一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。 elemtype代表类型，用于数据传递过程中的赋值； elemsize代表类型大小，用于在buf中定位元素位置。  锁  一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。  创建 chan  创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定  func makechan(t *chantype, size int) *hchan { var c *hchan c = new(hchan) c.</description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://convee.github.io/post/slice/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/slice/</guid>
      <description>Slice 实现原理  Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。接下来按照实际使用场景分别介绍其实现机制  Slice 数据结构 type slice struct { ​ array unsafe.Pointer ​ len int ​ cap int } 使用 make 创建 Slice slice := make([]int, 5, 10) 使用数组创建 Slice  使用数组来创建Slice时，Slice将与原数组共用一部分内存 切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5 数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方  slice := array[5:7] Slice 扩容  使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍 使用append()向Slice添加一个元素的实现步骤如下： ** 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice ** 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice ** 将新元素追加进新Slice，Slice.len++，返回新的Slice  Slice Copy  使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。 例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，copy过程中不会发生扩容。  特殊切片  跟据数组或切片生成新的切片一般使用slice := array[start:end]方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。 比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：  sliceA := make([]int, 5, 10) sliceB := sliceA[0:5]  根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：  ​ sliceA := make([]int, 5, 10) //length = 5; capacity = 10 ​ sliceB := sliceA[0:5] //length = 5; capacity = 10 ​ sliceC := sliceA[0:5:5] //length = 5; capacity = 5 编程Tips  创建切片时可跟据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能； 切片拷贝时需要判断实际拷贝的元素个数 谨慎使用多个切片操作同一个数组，以防读写冲突  Slice总结  每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片  </description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://convee.github.io/post/binary-tree/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/binary-tree/</guid>
      <description>二叉树知识点 二叉树遍历  前序遍历：先访问根结点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根结点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根结点  注意点： * 以根访问顺序决定是什么遍历 * 左子树都是优先右子树
 前序递归  func preorderTraversal(root *TreeNode) { if root==nil{ return } // 先访问根再访问左右 fmt.Println(root.Val) preorderTraversal(root.Left) preorderTraversal(root.Right) }  前序非递归  // V3：通过非递归遍历 func preorderTraversal(root *TreeNode) []int { // 非递归 if root == nil{ return nil } result:=make([]int,0) stack:=make([]*TreeNode,0) for root!=nil || len(stack)!=0{ for root !=nil{ // 前序遍历，所以先保存结果 result=append(result,root.Val) stack=append(stack,root) root=root.Left } // pop node:=stack[len(stack)-1] stack=stack[:len(stack)-1] root=node.Right } return result }  中序非递归  // 思路：通过stack 保存已经访问的元素，用于原路返回 func inorderTraversal(root *TreeNode) []int { result := make([]int, 0) if root == nil { return result } stack := make([]*TreeNode, 0) for len(stack) &amp;gt; 0 || root !</description>
    </item>
    
    <item>
      <title>算法 二进制</title>
      <link>https://convee.github.io/post/binary/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/binary/</guid>
      <description>常见的二进制操作 位运算    符号 描述 运算规则     &amp;amp; 与 两个位都为1时，结果才为1    或 两个位都为0时，结果才为0   ^ 异或 两个位相同为0，相异为1   ~ 取反 0变1，1变0   &amp;laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0      |右移|各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）
  基本操作  a=a^0=0^a 0=a^a a=a^b^b  交换两个数  a=a^b b=a^b a=a^b  移除最后一个 1  a=n&amp;amp;(n-1)  获取最后一个 1  diff=(n&amp;amp;(n-1))^n  </description>
    </item>
    
    <item>
      <title>算法思维</title>
      <link>https://convee.github.io/post/algorithm/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/algorithm/</guid>
      <description>学习算法和刷题框架思维 数据结构存储方式 数组（顺序存储）  紧凑连续存储，可以随机访问 通过索引快速找到对应元素 相对节约存储空间 正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N) 如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)  链表（链式存储）  元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题 如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1) 正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问 由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间  数据结构存储方式比较 队列和栈  数组：处理扩容问题 链表：需要更多的内存空间存储节点指针  图  邻接表（链表）：省空间，操作效率不如邻接矩阵 邻接矩阵（二维数组）：判断连通性迅速，如果图稀疏很耗空间  散列表  通过散列函数把键映射到一个大数组中 拉链法需要链表特性，操作简单，需要额外的空间存储指针 线性探查法需要数组特性，以便连续寻址，不需要指针的存储空间，操作复杂  树  数组实现就是「堆」，「堆」是一个完全二叉树，用数组存储不需要节点指针，操作简单 链表实现是常见的树，因为不一定是完全二叉树，所以不适合用数组存储 二叉树 数组  </description>
    </item>
    
    <item>
      <title>编译安装PHP</title>
      <link>https://convee.github.io/post/php/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/php/</guid>
      <description>安装依赖包 yum install -y gcc gcc-c++ make zlib zlib-devel pcre pcre-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp gmp-devel expat-devel libxml2 libxml2-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel libcurl libcurl-devel curl curl-devel libmcrypt libmcrypt-devel libxslt libxslt-devel xmlrpc-c xmlrpc-c-devel libicu-devel libmemcached-devel libzip readline readline-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers 下载 PHP wget https://www.php.net/distributions/php-7.3.20.tar.gz 解压 tar -xzvf php-7.3.20.tar.gz cd php-7.</description>
    </item>
    
    <item>
      <title>Post title here</title>
      <link>https://convee.github.io/post/post/</link>
      <pubDate>Wed, 17 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://convee.github.io/post/post/</guid>
      <description>Contents here Contents here Contents here Contents here  abc  </description>
    </item>
    
  </channel>
</rss>
